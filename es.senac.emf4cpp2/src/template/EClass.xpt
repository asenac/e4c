«IMPORT org::eclipse::emf::ecore»

«EXTENSION template::FQN»
«EXTENSION template::Queries»

«REM»Header«ENDREM»

«DEFINE generateHeader FOR EClass-»
«FILE getFilePrefix() + ".hpp"»
#ifndef «getHeader()»
#define «getHeader()»

#include <«EPackage.getFwdFile()»>
#include <«EPackage.getMetaFile()»>
«FOREACH ESuperTypes AS e-»
#include <«e.getFilePrefix()».hpp>
«ENDFOREACH-»
«IF ESuperTypes.isEmpty && getFQN() != "ecore::EObject"-»
#include <ecore/EObject.hpp>
«ENDIF-»

#include <e4c/mapping.hpp>

«EXPAND template::EPackage::namespacesBegin FOR EPackage»

// «getFQN()»
class «getName()»«IF !ESuperTypes.isEmpty» : «FOREACH ESuperTypes AS e SEPARATOR ", "» public virtual ::«e.getFQN()»«ENDFOREACH»«ENDIF»
{
public:

	typedef «name»_ptr ptr_type;
	
«IF !abstract-»
	«getName()»();
«ENDIF-»
	virtual ~«getName()»();

	«EXPAND generateTypedef FOREACH EStructuralFeatures»
	
	«EXPAND generateAccessors FOREACH EStructuralFeatures»
		
protected:
«IF abstract-»
	«getName()»();
«ENDIF-»

	«EXPAND generateDecl FOREACH EStructuralFeatures»
	
	«FOREACH EReferences.select(e|e.container) AS e-»
		«IF e.EType != this-»
	friend class ::«e.EType.getFQN()»;
		«ENDIF-»
	void set«e.getNameUpper()»(«e.getName()»_t «e.getName()»_);
	«ENDFOREACH-»
};

«EXPAND template::EPackage::namespacesEnd FOR EPackage»

#endif // «getHeader()»
«ENDFILE»
«ENDDEFINE»

«REM»Typedef«ENDREM»
«DEFINE generateTypedef FOR EStructuralFeature»«ENDDEFINE»

«DEFINE generateTypedef FOR EAttribute-»
	typedef ::«EType.getFQN()» «getName()»_t;
«ENDDEFINE»

«DEFINE generateTypedef FOR EReference-»
	typedef «getNoContaimentType()» «getName()»_t;
«ENDDEFINE»

«DEFINE generateDecl FOR EStructuralFeature-»
	«getName()»_t m_«getName()»;
«ENDDEFINE»

«DEFINE generateDecl FOR EReference-»
	«getReferenceType()» m_«getName()»;
«ENDDEFINE»

«REM»Accessors«ENDREM»
«DEFINE generateAccessors FOR EStructuralFeature»«ENDDEFINE»

«DEFINE generateAccessors FOR EAttribute-»
	void set«getNameUpper()»(«getName()»_t _«getName()»);
	«getName()»_t get«getNameUpper()»() const;
«ENDDEFINE»

«DEFINE generateAccessors FOR EReference-»
	«getName()»_t get«getNameUpper()»() const;
	«IF containment-»
		«IF upperBound == 1-»
	void set«getNameUpper()»(«getName()»_t «getName()»_);
	«getName()»_t release«getNameUpper()»();
		«ELSEIF ordered-»
	void add«getNameUpper()»(«getNoContaimentPtr()» «getName()»_);
		«ELSE-»
	void add«getNameUpper()»(«getNoContaimentPtr()» «getName()»_);
		«ENDIF-»
	«ELSEIF !container»
		«IF upperBound == 1-»
	void set«getNameUpper()»(«getName()»_t «getName()»_);
		«ELSE-»
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE generateAccessorsImpl FOR EStructuralFeature»«ENDDEFINE»

«DEFINE generateAccessorsImpl FOR EAttribute-»
void «EContainingClass.getName()»::set«getNameUpper()»(«getName()»_t _«getName()»)
{
	m_«getName()» = _«getName()»;;
}

«EContainingClass.getName()»::«getName()»_t «EContainingClass.getName()»::get«getNameUpper()»() const
{
	return m_«getName()»;
}

«ENDDEFINE»

«DEFINE generateAccessorsImpl FOR EReference-»
«EContainingClass.getName()»::«getName()»_t «EContainingClass.getName()»::get«getNameUpper()»() const
{
	return e4c::returned(m_«getName()»);
}

«IF containment-»
	«IF upperBound == 1-»
void «EContainingClass.getName()»::set«getNameUpper()»(«getName()»_t «getName()»_)
{
	m_«getName()».reset(«getName()»_);
	«IF EOpposite != null-»
	m_«getName()»->set«EOpposite.getNameUpper()»(this);
	«ENDIF-»
}

«EContainingClass.getName()»::«getName()»_t «EContainingClass.getName()»::release«getNameUpper()»()
{
	«IF EOpposite != null-»
	m_«getName()»->set«EOpposite.getNameUpper()»(0);
	«ENDIF-»
	return m_«getName()».release();
}
	«ELSEIF ordered-»
void «EContainingClass.getName()»::add«getNameUpper()»(«getNoContaimentPtr()» «getName()»_)
{
	«IF EOpposite != null-»
	«getName()»_->set«EOpposite.getNameUpper()»(this);
	«ENDIF-»
	m_«getName()».push_back(«getContaimentPtr()»(«getName()»_));
}
	«ELSE-»
void «EContainingClass.getName()»::add«getNameUpper()»(«getNoContaimentPtr()» «getName()»_)
{
	«IF EOpposite != null-»
	«getName()»_->set«EOpposite.getNameUpper()»(this);
	«ENDIF-»
	m_«getName()».insert(«getContaimentPtr()»(«getName()»_));
}
	«ENDIF-»
«ELSEIF container-»
void «EContainingClass.getName()»::set«getNameUpper()»(«getName()»_t «getName()»_)
{
	m_«getName()» = «getName()»_;
}
«ELSE-»
	«IF upperBound == 1-»
void «EContainingClass.getName()»::set«getNameUpper()»(«getName()»_t «getName()»_)
{
	«IF EOpposite != null && EOpposite.upperBound == 1-»;
	if (m_«getName()»)
		m_«getName()»->set«EOpposite.getNameUpper()»(0);
	«ENDIF-»
	m_«getName()» = «getName()»_;
	«IF EOpposite != null && EOpposite.upperBound == 1-»
	if (m_«getName()» && m_«getName()»->get«EOpposite.getNameUpper()»() != this)
		m_«getName()»->set«EOpposite.getNameUpper()»(this);
	«ENDIF-»
}
	«ELSE-»
	«ENDIF-»
«ENDIF»

«ENDDEFINE»

«REM»Impl«ENDREM»

«DEFINE generateImpl FOR EClass-»
«FILE getFilePrefix() + ".cpp"»
#include "«getName()».hpp"
«FOREACH EStructuralFeatures.typeSelect(EReference).EReferenceType.toSet() AS e-»
#include <«e.getFilePrefix()».hpp>
«ENDFOREACH-»

using namespace «EPackage.getFQN()»;

«getName()»::«getName()»()«IF !EStructuralFeatures.isEmpty-» : 
	«FOREACH EStructuralFeatures AS e SEPARATOR ",\n    "»m_«e.getName()»()«ENDFOREACH»«ENDIF»
{
}

«getName()»::~«getName()»()
{
}

«EXPAND generateAccessorsImpl FOREACH EStructuralFeatures»

«ENDFILE»
«ENDDEFINE»
